#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba32f) uniform image2D raymarchingRes;
layout(binding = 1, rgba32f) uniform image2D scene;
layout(binding = 2, r32f) uniform image2D sceneDepth;

uniform vec3 objectPos;
uniform vec3 objectOffset;
uniform vec3 cameraPos;
uniform vec3 camForward;
uniform vec3 camUp;
uniform vec3 camRight;
uniform vec2 resolution;
uniform float fov;
uniform float nearPlane;
uniform float farPlane;

uniform sampler3D densityTexture;

struct Ray
{
	vec3 pos;
	vec3 dir;
};

Ray CreateRay(vec3 pos, vec3 dir)
{
	Ray ray;
	ray.pos = pos;
	ray.dir = dir + 1e-20;
	return ray;
}

float sdfSphere(vec3 pos, float radius)
{
	return length(pos) - radius;
}

float sdfField(vec3 pos)
{
	return sdfSphere(pos, 0.1);
}

vec3 getNormal(vec3 pos)
{
	vec2 offset = vec2(0.001f,0.0f);
    vec3 n= vec3(
        sdfField(pos+offset.xyy)-sdfField(pos.xyy),
        sdfField(pos+offset.yxy)-sdfField(pos.yxy),
        sdfField(pos+offset.yyx)-sdfField(pos.yyx)
    );
    return normalize(n);
}

struct RayHit
{
	vec3 pos;
	vec3 normal;
};

RayHit CreateRayHit()
{
	RayHit rayHit;
	rayHit.pos = vec3(0, 0, 0);
	rayHit.normal = vec3(0, 0, 0);
	return rayHit;
};

void main()
{
	float x = (gl_GlobalInvocationID.x / resolution.x - 0.5f) * 2.f * nearPlane * tan(radians(fov / 2.f)) * resolution.x / resolution.y;
	float y = (gl_GlobalInvocationID.y / resolution.y - 0.5f) * 2.f * nearPlane * tan(radians(fov / 2.f));
	vec2 dir = vec2(x, y);

	vec3 pixelPos = cameraPos + camForward * nearPlane + dir.x * camRight + dir.y * camUp;
	Ray ray = CreateRay(cameraPos, normalize(pixelPos - cameraPos));

	// ray intersection
	vec3 firstIntersection = (objectPos - objectOffset - cameraPos) / ray.dir;
	vec3 secondIntersection = (objectPos + objectOffset - cameraPos) / ray.dir;
	vec3 closest = min(firstIntersection, secondIntersection);
	vec3 furthest = max(firstIntersection, secondIntersection);

	// the distance between camera and hit point of the nearst and furthest plane
	float t0 = max(closest.x, max(closest.y, closest.z));
	float t1 = min(furthest.x, min(furthest.y, furthest.z));

	t0 = max(0, t0);

	// the distance between entry point and out point
	float boxThickness = max(0, t1 - t0);
	vec3 entryPos = cameraPos + t0 * ray.dir;

	float shadowSteps = 64.f;
	float raymarchStep = 512.f;
	// ensure ray can walk through the volume
	int maxSteps = int(raymarchStep * length(2 * objectOffset)) + 1;

	vec3 lightVec = normalize(vec3(0, -1, -1));
	lightVec *= 1.f / shadowSteps * 0.5;
	vec3 localCamVec = ray.dir / raymarchStep / (2.f * objectOffset);

	// convert the sample range to 0-1
	vec3 curPos = (entryPos - objectPos + objectOffset) / (2.f * objectOffset);
	float curDensity = 0;
	float density = 64;
	float shadowDensity = 32;
	vec3 lightEnergy = vec3(0, 0, 0);
	float transmittance = 1;
	vec3 lightColor = vec3(0.6, 0.6, 0.6);
	float shadowThresh = 0.05;
	vec3 lightPos = vec3(0.f, 1.f, 0.4f);

	for (int i = 0; i < maxSteps; ++i)
	{	
		if (t1 - t0 <= 0)
			break;

		float cursample = texture(densityTexture, curPos).x;

		if(cursample > 0.001)
		{
			transmittance *= 1.f - cursample * 0.2;
			if (transmittance < 0.01)
				break;

			vec3 lightDir = normalize(lightPos - curPos) * 0.02;
			float transmittanceLight = 1.f;
			vec3 lightPos = curPos + lightDir;

			for (int s = 0; s < 50; ++s)
			{
				float lightSample = texture(densityTexture, lightPos).x;

				if (lightSample < 0.001)
					continue;

				transmittanceLight *= 1.f - lightSample * 0.2;

				if (transmittanceLight < 0.01)
					break;

				lightPos += lightDir;
			}

			vec3 lightE = vec3(0.584f, 0.514f, 0.451f) * transmittanceLight;

			lightEnergy += lightE * cursample * transmittance;
		}

		curPos += localCamVec;
	}

	vec4 inScene = imageLoad(scene, ivec2(gl_GlobalInvocationID.xy));
	vec3 sceneColor = inScene.xyz;

	float depth = inScene.w;
	float objDepth = (1 / t0 - 1 / nearPlane) / (1 / farPlane - 1 / nearPlane);

	vec3 finalColor = lightEnergy * 0.3f;

	if (sceneColor != vec3(0.f, 0.f, 0.f))
		finalColor = vec3(0.5f, 0.5f, 0.5f);

	imageStore(raymarchingRes, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1));
}