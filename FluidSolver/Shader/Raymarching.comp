#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba32f) uniform image2D rayDir;
layout(binding = 1, rgba32f) uniform image2D raymarchingRes;
//layout(binding = 2, rgba32f) uniform image3D densityTexture;

uniform vec3 objectPos;
uniform vec3 objectOffset;
uniform vec3 cameraPos;
uniform vec3 camForward;

uniform sampler3D densityTexture;

struct Ray
{
	vec3 pos;
	vec3 dir;
};

Ray CreateRay(vec3 pos, vec3 dir)
{
	Ray ray;
	ray.pos = pos;
	ray.dir = dir;
	return ray;
}

void main()
{
	vec2 dir = imageLoad(rayDir, ivec2(gl_GlobalInvocationID.xy)).xy;
	// direction: x right, y up, z forward
	vec3 camUp = vec3(0, 1, 0);
	vec3 camRight = cross(camForward, camUp);
	camUp = cross(camRight, camForward);

	vec3 pixelPos = cameraPos + camForward * 0.5 + dir.x * camRight + dir.y * camUp;
	Ray ray = CreateRay(cameraPos, normalize(pixelPos - cameraPos));

	// ray intersection
	vec3 firstIntersection = (objectPos - objectOffset - cameraPos) / ray.dir;
	vec3 secondIntersection = (objectPos + objectOffset - cameraPos) / ray.dir;
	vec3 closest = min(firstIntersection, secondIntersection);
	vec3 furthesr = max(firstIntersection, secondIntersection);

	// the distance between camera and hit point of the nearst and furthest plane
	float t0 = max(closest.x, max(closest.y, closest.z));
	float t1 = min(furthesr.x, min(furthesr.y, furthesr.z));

	t0 = max(0, t0);

	// the distance between entry point and out point
	float boxThickness = max(0, t1 - t0);
	vec3 entryPos = cameraPos + max(0, t0) * ray.dir;

	int shadowSteps = 64;
	int raymarchStep = 512;
	// ensure ray can walk through the volume
	int maxSteps = int(raymarchStep * length(2 * objectOffset)) + 1;

	vec3 lightVec = normalize(vec3(0, 0, -1));
	lightVec *= 1 / shadowSteps * 0.5;
	vec3 localCamVec = ray.dir / raymarchStep;

	// convert the sample range to 0-1
	vec3 curPos = (entryPos - objectPos + objectOffset) / (2 * objectOffset);
	float curDensity = 0;
	float density = 64;
	float shadowDensity = 32;
	vec3 lightEnergy = vec3(0, 0, 0);
	float transmittance = 1;
	vec3 lightColor = vec3(0.6, 0.6, 0.6);
	float shadowThresh = 0.05;

	for (int i = 0; i < maxSteps; i++)
	{	
		float cursample = texture(densityTexture, curPos).x;

		if(cursample > 0.001)
		{
			vec3 lpos = curPos;
			float shadowDist = 0;

			curDensity = 1 - exp(-cursample * density);

			lightEnergy += curDensity * transmittance * 0.01;
		}

		curPos += localCamVec;
	}

	imageStore(raymarchingRes, ivec2(gl_GlobalInvocationID.xy), vec4(lightEnergy, 1));
}